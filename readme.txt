TODO :

1. Две стратегии для вызова точки восстановления

  - первая (обычная) - сохранение состояния стека и локальных переменных после вызова,
    аргументы в этом способе подставляются дефолтные, а вызываемая функция дополнительно сохраняет this

  - с сохранением аргументов перед вызовом - для сохранения вызовов точек восстановления, на которые мы
    не можем повлиять (не можем инструментировать вызов reflection api, который далее может привести к вызову
    yield). Сохраняем аргументы перед вызовом каждый раз (не обязательно сохранять весь стек, достаточно сохранить
    только N аргументов вызова рестор-поинта).

Алгоритм сохранения и восстановления контекста:

Порядок сохранения:

1. Сохранить содержимое дна стека (вершина стека, которая содержит ссылку на экземпляр след объекта в цепочке вызовов, и
   аргументы вызова, - нас не интересуют, они будут сохранены самим методом)

2. Сохранить локальные переменные (это место как раз и даёт нам возможность не сохранять аргументы)

3. Сохранить this (если текущий метод - экземплярный)

Порядок восстановления:

1. Восстановить локальные переменные (в порядке, обратном порядку сохранения)

2. Восстановить дно стека (в порядке, обратном порядку сохранения)

3. Добавить в стек значения по умолчанию для следующего вызова в цепочке восстановления.
   Для ссылочных типов это будут null'ы, для целых и значений типа double - нули.

4. Восстановить ссылку на экземпляр, если следующий вызываемый метод в цепочке - экземплярный

Стек до вызова метода foo(int, double, String)

String       \
double         аргументы снизу вверх
int          /
instanceRef - ссылка на экземпляр
stack_2   \
stack_1     дно стека
stack_0   /

Стек после вызова метода

returnedValue - возвращаемое значение
stack_2  \
stack_1    дно стека
stack_0  /

Следует обратить внимание также и на то, что значение, которое вернул метод, нам при сохранении контекста не нужно
(оно null или 0, ведь метод завершился преждевременно), и мы его просто выбрасываем.

Что такое точка восстановления ?

Нужно ли рассматривать вызов метода methodId как вызов, внутри которого может произойти вызов yield(),
или такого не может произойти ? Если есть вероятность, что при вызове methodId произойдёт вызов yield(),
то мы должны рассматривать этот вызов как точку восстановления, и обрамлять вызов метода соответствующим
байткодом.

TODO : придумать что-нибудь с синтетическими методами, которые генерятся при вызове private метода
из иннер класса

todo : В ядре

+ 1. Поддержать вложенные сопрограммы

2. Поддержать аннотирование лямбд

3. Написать тесты на методы с разными типами локальных переменных и параметров
(boolean, char, short, byte, float, array)

+ 4. Написать тест с рекурсивной функцией, которая в конечном итоге зовёт yield()

5. Поддержать вторую стратегию сохранения-восстановления контекста (для поддержки
неинструментируемых точек восстановления - например, если точка восстановления лежит через вызов reflection API).

6. Сконфигурировать логирование при инструментировании, показывать варнинги, когда точка восстановления
задекларирована, но не найдена в теле метода (например из-за синтетического private метода)

+ 7. Теоретически может быть такое, что ICoroRunnable.run() не является рутовой точкой входа сопрограммы
(например, вызывается из другой точки восстановления). Нужно дать возможность обработать такой сценарий.
Также проблема возникнет, если ICoroRunnable.run() - одновременно рутовая и рекурсивная. Пока непонятно, как решить
эту траблу :)

8. Написать User Guide

10. Написать статью, разъясняющую принцип работы

11. Сделать FAQ

12. Заменить везде сравнение BasicValue.XXX == yyy на switch(value.getType().getSort())
тк теперь там могут быть другие значения